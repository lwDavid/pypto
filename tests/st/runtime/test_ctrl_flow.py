# Copyright (c) PyPTO Contributors.
# This program is free software, you can redistribute it and/or modify it under the terms and conditions of
# CANN Open Software License Agreement Version 2.0 (the "License").
# Please refer to the License for details. You may not use this file except in compliance with the License.
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
# See LICENSE in the root of the software repository for the full text of the License.
# -----------------------------------------------------------------------------------------------------------

"""
Tests for control flow code generation (scf.for) using PyPTO frontend.

This module validates that scf.for is correctly generated by the PTO codegen,
ensuring correct code generation and execution for loop patterns.

Limitations:
    scf.if (if-else) inside InCore functions with tile operations is not yet
    fully supported at runtime. The BasicMemoryReuse pass does not track
    variable uses inside IfStmt branches, causing incorrect buffer reuse.
    Additionally, the PTO codegen's ForStmt/IfStmt type inference only handles
    ScalarType for iter_args/return_vars (TileType/TensorType fall through to
    "index"). These limitations need to be addressed before if-else runtime
    tests can be added.
"""

from typing import Any

import pypto.language as pl
import pytest
from harness.core.harness import DataType, PTOTestCase, TensorSpec
from pypto.backend import BackendType
from pypto.ir.pass_manager import OptimizationStrategy


class TestForLoopAdd(PTOTestCase):
    """Test tile add inside a for loop (1 iteration).

    Validates scf.for code generation. The loop runs once,
    performing a simple tile add. Expected result: c = a + b.
    """

    __test__ = False

    def get_name(self) -> str:
        return "for_loop_add_64x64"

    def define_tensors(self) -> list[TensorSpec]:
        return [
            TensorSpec("a", [256, 64], DataType.FP32, init_value=2.0),
            TensorSpec("b", [256, 64], DataType.FP32, init_value=3.0),
            TensorSpec("c", [256, 64], DataType.FP32, is_output=True),
        ]

    def get_program(self) -> Any:
        @pl.program
        class ForLoopAddProgram:
            @pl.function(type=pl.FunctionType.InCore)
            def kernel_add_loop(
                self,
                a: pl.Tensor[[256, 64], pl.FP32],
                b: pl.Tensor[[256, 64], pl.FP32],
                c: pl.Out[pl.Tensor[[256, 64], pl.FP32]],
            ) -> pl.Tensor[[256, 64], pl.FP32]:
                for i in pl.range(4):
                    offset_i = i * 64
                    tile_a: pl.Tile[[64, 64], pl.FP32] = pl.load(a, [offset_i, 0], [64, 64])
                    tile_b: pl.Tile[[64, 64], pl.FP32] = pl.load(b, [offset_i, 0], [64, 64])
                    tile_c: pl.Tile[[64, 64], pl.FP32] = pl.add(tile_a, tile_b)
                    out: pl.Tensor[[256, 64], pl.FP32] = pl.store(tile_c, [offset_i, 0], [64, 64], c)
                return out

            @pl.function(type=pl.FunctionType.Orchestration)
            def orchestrator(
                self,
                a: pl.Tensor[[256, 64], pl.FP32],
                b: pl.Tensor[[256, 64], pl.FP32],
            ) -> pl.Tensor[[256, 64], pl.FP32]:
                c: pl.Tensor[[256, 64], pl.FP32] = pl.create_tensor([256, 64], dtype=pl.FP32)
                c = self.kernel_add_loop(a, b, c)
                return c

        return ForLoopAddProgram

    def compute_expected(self, tensors, params=None):
        tensors["c"][:] = tensors["a"] + tensors["b"]


class TestForLoopAddPTO(TestForLoopAdd):
    """Test for loop add with PTO backend and PTOAS optimization."""

    __test__ = False

    def get_name(self) -> str:
        return "for_loop_add_pto_64x64"

    def get_strategy(self) -> OptimizationStrategy:
        return OptimizationStrategy.PTOAS

    def get_backend_type(self) -> BackendType:
        return BackendType.PTO


class TestForLoopMul(PTOTestCase):
    """Test tile mul inside a for loop (1 iteration).

    Validates scf.for code generation with a different operation.
    Expected result: c = a * b.
    """

    __test__ = False

    def get_name(self) -> str:
        return "for_loop_mul_64x64"

    def define_tensors(self) -> list[TensorSpec]:
        return [
            TensorSpec("a", [256, 64], DataType.FP32, init_value=2.0),
            TensorSpec("b", [256, 64], DataType.FP32, init_value=3.0),
            TensorSpec("c", [256, 64], DataType.FP32, is_output=True),
        ]

    def get_program(self) -> Any:
        @pl.program
        class ForLoopMulProgram:
            @pl.function(type=pl.FunctionType.InCore)
            def kernel_mul_loop(
                self,
                a: pl.Tensor[[256, 64], pl.FP32],
                b: pl.Tensor[[256, 64], pl.FP32],
                c: pl.Out[pl.Tensor[[256, 64], pl.FP32]],
            ) -> pl.Tensor[[256, 64], pl.FP32]:
                for i in pl.range(4):
                    offset_i = i * 64
                    tile_a: pl.Tile[[64, 64], pl.FP32] = pl.load(a, [offset_i, 0], [64, 64])
                    tile_b: pl.Tile[[64, 64], pl.FP32] = pl.load(b, [offset_i, 0], [64, 64])
                    tile_c: pl.Tile[[64, 64], pl.FP32] = pl.mul(tile_a, tile_b)
                    out: pl.Tensor[[256, 64], pl.FP32] = pl.store(tile_c, [offset_i, 0], [64, 64], c)
                return out

            @pl.function(type=pl.FunctionType.Orchestration)
            def orchestrator(
                self,
                a: pl.Tensor[[256, 64], pl.FP32],
                b: pl.Tensor[[256, 64], pl.FP32],
            ) -> pl.Tensor[[256, 64], pl.FP32]:
                c: pl.Tensor[[256, 64], pl.FP32] = pl.create_tensor([256, 64], dtype=pl.FP32)
                c = self.kernel_mul_loop(a, b, c)
                return c

        return ForLoopMulProgram

    def compute_expected(self, tensors, params=None):
        tensors["c"][:] = tensors["a"] * tensors["b"]


class TestForLoopMulPTO(TestForLoopMul):
    """Test for loop mul with PTO backend and PTOAS optimization."""

    __test__ = False

    def get_name(self) -> str:
        return "for_loop_mul_pto_64x64"

    def get_strategy(self) -> OptimizationStrategy:
        return OptimizationStrategy.PTOAS

    def get_backend_type(self) -> BackendType:
        return BackendType.PTO


# =============================================================================
# pytest test functions
# =============================================================================


class TestCtrlFlowOperations:
    """Test suite for control flow operations."""

    @pytest.mark.xfail(reason="test_for_loop_add is currently failing due to insertsync bug", strict=False)
    def test_for_loop_add(self, test_runner):
        """Test for loop wrapping tile add."""
        test_case = TestForLoopAdd()
        result = test_runner.run(test_case)
        assert result.passed, f"Test failed: {result.error}"

    def test_for_loop_add_pto(self, test_runner):
        """Test for loop add with PTO backend and PTOAS."""
        test_case = TestForLoopAddPTO()
        result = test_runner.run(test_case)
        assert result.passed, f"Test failed (PTO): {result.error}"

    @pytest.mark.xfail(reason="test_for_loop_mul is currently failing due to insertsync bug", strict=False)
    def test_for_loop_mul(self, test_runner):
        """Test for loop wrapping tile mul."""
        test_case = TestForLoopMul()
        result = test_runner.run(test_case)
        assert result.passed, f"Test failed: {result.error}"

    def test_for_loop_mul_pto(self, test_runner):
        """Test for loop mul with PTO backend and PTOAS."""
        test_case = TestForLoopMulPTO()
        result = test_runner.run(test_case)
        assert result.passed, f"Test failed (PTO): {result.error}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
